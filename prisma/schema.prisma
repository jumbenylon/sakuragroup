// v2.4 â€” Enterprise Hardened (Enums & Referential Integrity)

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  USER
  ADMIN
}

enum AccountStatus {
  PENDING
  ACTIVE
  SUSPENDED
}

enum CampaignStatus {
  DRAFT
  COMMITTED
  QUEUED
  PROCESSING
  COMPLETE
  PARTIAL
}

enum MessageStatus {
  PENDING
  PROCESSING
  SENT
  FAILED
}

model User {
  id        String        @id @default(uuid())
  email     String        @unique
  password  String
  role      Role          @default(USER)
  status    AccountStatus @default(ACTIVE)
  balance   Int           @default(0) // TZS Minor Units
  smsRate   Int           @default(25)

  senderIds SenderId[]
  campaigns Campaign[]
  messages  MessageLog[]
  apiKeys   ApiKey[]
  sessions  Session[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Session {
  id           String   @id @default(uuid())
  token        String   @unique
  userId       String
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  ipAddress    String?
  userAgent    String?
  expiresAt    DateTime
  createdAt    DateTime @default(now())
}

model ApiKey {
  id        String   @id @default(uuid())
  key       String   @unique 
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
}

model SenderId {
  id          String        @id @default(uuid())
  name        String
  status      MessageStatus @default(PENDING) // Reusing PENDING/SENT/FAILED as proxy for Approval
  userId      String
  user        User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  approvedBy  String?
  approvedAt  DateTime?
  rejectedBy  String?
  rejectedAt  DateTime?

  campaigns   Campaign[]
  messages    MessageLog[]

  createdAt   DateTime @default(now())

  @@unique([name, userId]) 
}

model Campaign {
  id               String         @id @default(uuid())
  userId           String
  user             User           @relation(fields: [userId], references: [id])
  
  senderId         String?
  sender           SenderId?      @relation(fields: [senderId], references: [id], onDelete: SetNull)

  senderName       String
  metaIp           String?
  metaUa           String?

  status           CampaignStatus @default(DRAFT)
  totalRecipients  Int
  totalSegments    Int
  totalCost        Int            // minor units
  
  messages         MessageLog[]
  createdAt        DateTime       @default(now())
}

model MessageLog {
  id               String        @id @default(uuid())
  campaignId       String?   
  campaign         Campaign?     @relation(fields: [campaignId], references: [id], onDelete: SetNull)
  
  userId           String
  user             User          @relation(fields: [userId], references: [id])
  
  senderId         String?
  sender           SenderId?     @relation(fields: [senderId], references: [id], onDelete: SetNull)
  
  senderName       String?

  recipient        String
  message          String
  segmentCount     Int
  costToTenant     Int       
  costToAdmin      Int           @default(19) 
  status           MessageStatus @default(PENDING)

  providerMessageId String?
  providerError      String?

  scheduledAt      DateTime?
  sentAt           DateTime?
  createdAt        DateTime      @default(now())
}
